/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 67c9a1eda264be4cfe0bb2c76151f0aadf0862bc
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
    AttachmentMetaData,
    AttachmentMetaDataFromJSON,
    AttachmentMetaDataToJSON,
    Email,
    EmailFromJSON,
    EmailToJSON,
    ForwardEmailOptions,
    ForwardEmailOptionsFromJSON,
    ForwardEmailOptionsToJSON,
    PageEmailProjection,
    PageEmailProjectionFromJSON,
    PageEmailProjectionToJSON,
    RawEmailJson,
    RawEmailJsonFromJSON,
    RawEmailJsonToJSON,
    UnreadCount,
    UnreadCountFromJSON,
    UnreadCountToJSON,
    ValidationDto,
    ValidationDtoFromJSON,
    ValidationDtoToJSON,
} from '../models';

export interface DeleteEmailRequest {
    emailId: string;
}

export interface DownloadAttachmentRequest {
    attachmentId: string;
    emailId: string;
    apiKey?: string;
}

export interface ForwardEmailRequest {
    emailId: string;
    forwardEmailOptions: ForwardEmailOptions;
}

export interface GetAttachmentMetaDataRequest {
    attachmentId: string;
    emailId: string;
}

export interface GetAttachmentsRequest {
    emailId: string;
}

export interface GetEmailRequest {
    emailId: string;
    decode?: boolean;
}

export interface GetEmailHTMLRequest {
    emailId: string;
    decode?: boolean;
}

export interface GetEmailsPaginatedRequest {
    inboxId?: Array<string>;
    page?: number;
    size?: number;
    sort?: GetEmailsPaginatedSortEnum;
    unreadOnly?: boolean;
}

export interface GetRawEmailContentsRequest {
    emailId: string;
}

export interface GetRawEmailJsonRequest {
    emailId: string;
}

export interface ValidateEmailRequest {
    emailId: string;
}

/**
 * no description
 */
export class EmailControllerApi extends runtime.BaseAPI {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * Delete all emails
     */
    async deleteAllEmailsRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * Delete all emails
     */
    async deleteAllEmails(): Promise<void> {
        await this.deleteAllEmailsRaw();
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * Delete an email
     */
    async deleteEmailRaw(
        requestParameters: DeleteEmailRequest
    ): Promise<runtime.ApiResponse<void>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling deleteEmail.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * Delete an email
     */
    async deleteEmail(requestParameters: DeleteEmailRequest): Promise<void> {
        await this.deleteEmailRaw(requestParameters);
    }

    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * Get email attachment bytes
     */
    async downloadAttachmentRaw(
        requestParameters: DownloadAttachmentRequest
    ): Promise<runtime.ApiResponse<string>> {
        if (
            requestParameters.attachmentId === null ||
            requestParameters.attachmentId === undefined
        ) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter requestParameters.attachmentId was null or undefined when calling downloadAttachment.'
            );
        }

        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling downloadAttachment.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.apiKey !== undefined) {
            queryParameters['apiKey'] = requestParameters.apiKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments/{attachmentId}`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(requestParameters.attachmentId))
                )
                .replace(
                    `{${'emailId'}}`,
                    encodeURIComponent(String(requestParameters.emailId))
                ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * Get email attachment bytes
     */
    async downloadAttachment(
        requestParameters: DownloadAttachmentRequest
    ): Promise<string> {
        const response = await this.downloadAttachmentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Forward an existing email to new recipients.
     * Forward email
     */
    async forwardEmailRaw(
        requestParameters: ForwardEmailRequest
    ): Promise<runtime.ApiResponse<void>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling forwardEmail.'
            );
        }

        if (
            requestParameters.forwardEmailOptions === null ||
            requestParameters.forwardEmailOptions === undefined
        ) {
            throw new runtime.RequiredError(
                'forwardEmailOptions',
                'Required parameter requestParameters.forwardEmailOptions was null or undefined when calling forwardEmail.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/forward`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ForwardEmailOptionsToJSON(
                requestParameters.forwardEmailOptions
            ),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Forward an existing email to new recipients.
     * Forward email
     */
    async forwardEmail(requestParameters: ForwardEmailRequest): Promise<void> {
        await this.forwardEmailRaw(requestParameters);
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * Get email attachment metadata
     */
    async getAttachmentMetaDataRaw(
        requestParameters: GetAttachmentMetaDataRequest
    ): Promise<runtime.ApiResponse<AttachmentMetaData>> {
        if (
            requestParameters.attachmentId === null ||
            requestParameters.attachmentId === undefined
        ) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter requestParameters.attachmentId was null or undefined when calling getAttachmentMetaData.'
            );
        }

        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getAttachmentMetaData.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments/{attachmentId}/metadata`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(requestParameters.attachmentId))
                )
                .replace(
                    `{${'emailId'}}`,
                    encodeURIComponent(String(requestParameters.emailId))
                ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            AttachmentMetaDataFromJSON(jsonValue)
        );
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * Get email attachment metadata
     */
    async getAttachmentMetaData(
        requestParameters: GetAttachmentMetaDataRequest
    ): Promise<AttachmentMetaData> {
        const response = await this.getAttachmentMetaDataRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * Get all email attachment metadata
     */
    async getAttachmentsRaw(
        requestParameters: GetAttachmentsRequest
    ): Promise<runtime.ApiResponse<Array<AttachmentMetaData>>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getAttachments.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/attachments`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            jsonValue.map(AttachmentMetaDataFromJSON)
        );
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * Get all email attachment metadata
     */
    async getAttachments(
        requestParameters: GetAttachmentsRequest
    ): Promise<Array<AttachmentMetaData>> {
        const response = await this.getAttachmentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * Get email content
     */
    async getEmailRaw(
        requestParameters: GetEmailRequest
    ): Promise<runtime.ApiResponse<Email>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getEmail.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.decode !== undefined) {
            queryParameters['decode'] = requestParameters.decode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            EmailFromJSON(jsonValue)
        );
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * Get email content
     */
    async getEmail(requestParameters: GetEmailRequest): Promise<Email> {
        const response = await this.getEmailRaw(requestParameters);
        return await response.value();
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * Get email content as HTML
     */
    async getEmailHTMLRaw(
        requestParameters: GetEmailHTMLRequest
    ): Promise<runtime.ApiResponse<string>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getEmailHTML.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.decode !== undefined) {
            queryParameters['decode'] = requestParameters.decode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/html`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * Get email content as HTML
     */
    async getEmailHTML(
        requestParameters: GetEmailHTMLRequest
    ): Promise<string> {
        const response = await this.getEmailHTMLRaw(requestParameters);
        return await response.value();
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * Get all emails
     */
    async getEmailsPaginatedRaw(
        requestParameters: GetEmailsPaginatedRequest
    ): Promise<runtime.ApiResponse<PageEmailProjection>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.inboxId) {
            queryParameters['inboxId'] = requestParameters.inboxId;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.unreadOnly !== undefined) {
            queryParameters['unreadOnly'] = requestParameters.unreadOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            PageEmailProjectionFromJSON(jsonValue)
        );
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * Get all emails
     */
    async getEmailsPaginated(
        requestParameters: GetEmailsPaginatedRequest
    ): Promise<PageEmailProjection> {
        const response = await this.getEmailsPaginatedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * Get raw email string
     */
    async getRawEmailContentsRaw(
        requestParameters: GetRawEmailContentsRequest
    ): Promise<runtime.ApiResponse<string>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getRawEmailContents.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/raw`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * Get raw email string
     */
    async getRawEmailContents(
        requestParameters: GetRawEmailContentsRequest
    ): Promise<string> {
        const response = await this.getRawEmailContentsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * Get raw email in JSON
     */
    async getRawEmailJsonRaw(
        requestParameters: GetRawEmailJsonRequest
    ): Promise<runtime.ApiResponse<RawEmailJson>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling getRawEmailJson.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/raw/json`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            RawEmailJsonFromJSON(jsonValue)
        );
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * Get raw email in JSON
     */
    async getRawEmailJson(
        requestParameters: GetRawEmailJsonRequest
    ): Promise<RawEmailJson> {
        const response = await this.getRawEmailJsonRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get number of emails unread
     * Get unread email count
     */
    async getUnreadEmailCountRaw(): Promise<runtime.ApiResponse<UnreadCount>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/unreadCount`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            UnreadCountFromJSON(jsonValue)
        );
    }

    /**
     * Get number of emails unread
     * Get unread email count
     */
    async getUnreadEmailCount(): Promise<UnreadCount> {
        const response = await this.getUnreadEmailCountRaw();
        return await response.value();
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * Validate email
     */
    async validateEmailRaw(
        requestParameters: ValidateEmailRequest
    ): Promise<runtime.ApiResponse<ValidationDto>> {
        if (
            requestParameters.emailId === null ||
            requestParameters.emailId === undefined
        ) {
            throw new runtime.RequiredError(
                'emailId',
                'Required parameter requestParameters.emailId was null or undefined when calling validateEmail.'
            );
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/emails/{emailId}/validate`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(requestParameters.emailId))
            ),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            ValidationDtoFromJSON(jsonValue)
        );
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * Validate email
     */
    async validateEmail(
        requestParameters: ValidateEmailRequest
    ): Promise<ValidationDto> {
        const response = await this.validateEmailRaw(requestParameters);
        return await response.value();
    }
}

/**
 * @export
 * @enum {string}
 */
export enum GetEmailsPaginatedSortEnum {
    ASC = 'ASC',
    DESC = 'DESC',
}
